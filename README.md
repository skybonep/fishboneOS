# fishboneOS

**fishboneOS** is a simple system made of small, separate parts. You can pick the pieces you like and put them together to build your own custom system. Every piece can be changed or replaced easily. It is built for user choice and simple connections. We are starting with a small base to grow a project that is easy to use.

## Project Goals
The core vision of fishboneOS is to provide an ultra-modular operating system "playground" for developers. Unlike traditional systems with fixed cores, this project treats every component—including the kernel—as a replaceable module.

- Extreme Modularity: Inspired by projects like LegoOS and CharlotteOS, the system splits traditional OS functionalities into loosely-coupled monitors or modules. Users can select their preferred modules at installation-time to create a custom build. Furthermore, the system aims to allow the replacement of modules at run-time, providing a dynamic environment for testing new drivers or managers.

- User-Driven Customization: Users should be able to select specific modules—such as different filesystems, schedulers, or drivers—to assemble an OS tailored to their specific hardware or task requirements.

- A "No Must-Have" Philosophy: In this architecture, there are no "hard" dependencies. Even the kernel is treated as a module, allowing a developer to swap out a monolithic kernel for a microkernel or a specialized research manager depending on their needs.

- Developer-First Design: The initial target audience is developers and researchers. Because these users possess the technical knowledge to understand specific module functions, they can better navigate the choices required to assemble a functional system.

- Stability through Modular Isolation: To ensure that a "bad" or experimental module does not "nuke" the entire system, fishboneOS will implement graceful failure mechanisms
. This isolation ensures that if one module fails, the rest of the system remains retrievable and stable.

- Simplicity over Performance: The codebase will prioritize clean, readable C and Assembly. The goal is a system that is easy to audit and modify, ensuring it can be used and understood by other people in the OSDev community.

## Roadmap and Milestones

Current Status: Phase 0 (Writing this document)

This roadmap is generated by AI, it is just a guideline for me, so it is subject to change.

### Phase 1: The Bare Bones (Understanding the Basics)
This phase focuses on the fundamental "bootstrap" process required to get any code running on the hardware.
- Development Environment: Set up the toolchain (GCC cross-compiler, NASM, and the Bochs emulator).
- Hello Cafebabe: Create a minimal kernel that adheres to the Multiboot specification so it can be loaded by GRUB. The milestone is reached when the CPU registers show 0xCAFEBABE after booting.
- The Stack & C Entry Point: Set up a stack in the .bss section of the kernel. This allows the transition from Assembly to a C entry point (kmain).
- Basic Output (The Logger): Implement a Serial Port driver. This is vital for developers because it allows Bochs to store log messages in a file, creating a permanent record for debugging.

### Phase 2: CPU and Memory Infrastructure
These components are "necessary" because they establish the rules for how your modular parts will interact and stay protected.
- Global Descriptor Table (GDT): Define segments for the kernel and future user modules to establish privilege levels (Ring 0 and Ring 3).
- Interrupts (IDT/PIC): Configure the Interrupt Descriptor Table and remap the Programmable Interrupt Controller. This enables the OS to receive signals from hardware like the keyboard.
- Paging (Virtual Memory): Enable Paging to translate linear addresses to physical ones.
- The Higher-Half Kernel: Relocate the kernel to a high virtual address like 0xC0100000. This ensures that the lower address space remains free for user-selected modules.

### Phase 3: The Modular Framework (Your Core Vision)
Once the basics are stable, you can begin implementing your vision of a system with replaceable components.
- Page Frame Allocator: Create a system (such as a Bitmap) to track which parts of physical memory are free.
- Module Loading (GRUB Modules): Use GRUB to load external files into memory as modules. Your kernel will parse the Multiboot structure to find these programs and execute them.
- The Road to User Mode: Implement the mechanism to jump into User Mode (PL3). This provides the "isolation" you desired, preventing a bad module from crashing the entire system.
- System Calls: Build the interface that modules use to request resources from the kernel.

### Phase 4: Developer Ecosystem & Advanced Modularity
- Cooperative Multitasking: Implement a yield system call where modules voluntarily give up CPU time to allow other modules to run.
- Virtual File System (VFS): Create an abstraction layer that treats everything—from the screen to modules—as a file, allowing for easy interchangeability.
- Run-time Replacement: Develop the logic to safely swap out a module (like a driver) while the system is running by updating internal tables.

## Development Environment
The project is developed on a Linux host, which provides a slight advantage in tool availability.

- Compiler: GCC (configured as a cross-compiler to avoid host runtime file linking).
- Assembler: NASM (chosen for its preferred syntax).
- Build System: GNU Make for build automation.
- Emulator: Bochs (IA-32) for its specialized debugging features and log output.

## Building and Running
Warning: It is highly recommended to run this project in a virtual machine or emulator.

1. Install Dependencies:
   sudo apt-get install build-essential nasm genisoimage bochs bochs-sdl

2. Compile and Build ISO:
   make os.iso

3. Run in Bochs:
   make run

 Current Status
Following the "Hello Cafebabe" milestone, the project is currently in its initial stages
.
- [x] Bootloader: GRUB Legacy (Multiboot compliant)
.
- [x] Core Milestone: Successfully writes 0xCAFEBABE to the EAX register
.
- [x] C Environment: Stack initialization in the .bss section
.
- [ ] GDT: Setting up segment descriptors for privilege levels
.
- [ ] Paging: Implementing a higher-half kernel at 0xC0100000
.
- [ ] Interrupts: IDT setup and hardware interrupt remapping
.

## Beginner Mistakes to Avoid
- **Neglecting Version Control**: Failing to use a version control system like Git immediately is a critical error; without it, a single "poorly written 'rm' or 'format' command" or a disk crash can destroy hundreds of hours of work.

- **Skipping the Cross-Compiler**: Beginners often make the mistake of using their host system's default compiler. This is dangerous because it can lead to the incorrect linking of host runtime files into your kernel; a dedicated cross-compiler is required.

- **Attempting to Load at Address 0**: Trying to load your kernel at the very beginning of physical memory (below 1 MB) is a mistake, as this area is strictly reserved for the BIOS, GRUB, and memory-mapped I/O.

- **Skipping Foundational Knowledge**: Many beginners try to skip learning the "abstract theory" of computer science or the complexities of assembly language. The sources emphasize that you cannot skip these requirements if you want to successfully handle hardware interactions.

- **The "Sloppy Code" Mentality**: Assuming that modern computers are fast enough to handle inefficient code is a dangerous mentality in OS design. Critical kernel code may be called thousands of times per second, requiring you to remove as much overhead as possible.

- **Over-complicating Early Paging**: Jumping straight into complex paging structures often leads to hard-to-debug crashes. The sources recommend starting with identity paging (mapping virtual addresses to the same physical addresses) before moving to advanced setups like a higher-half kernel.

- **Ignoring Hardware Manuals**: OS development requires reading and writing complex assembly based on hardware specifications. Failing to consult official documentation, such as the Intel Manuals, leads to unnecessary confusion and discouragement.

- **Expecting Instant Gratification**: A common psychological mistake is expecting the same "instant gratification" found in web or game development. OS development is a "complicated and ongoing process" that requires extreme patience.

- **Forgoing Standard Allocators**: Some beginners attempt to "forego the page allocator" to simplify early development, but this often results in significant "headaches" when trying to copy data between kernel and userspace memory later on.

## References
This project draws technical knowledge and inspiration from the following resources:
- The OSDev Wiki
- The Intel 64 and IA-32 Architectures Software Developer’s Manuals
- "The Little Book about OS Development" by Erik Helin and Adam Renberg
- "Think OS" by Allen B. Downey

## License
All content is under the Creative Commons Attribution Non Commercial Share Alike 3.0 license. Code samples are provided for educational use.


